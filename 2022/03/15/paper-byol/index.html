<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
<meta name="google-site-verification" content="nRdQ64asSdtMIPKmtAL6qJO9Ka3rBCML55licirmHbo" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/panda-apple.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/panda-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/panda-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"timeoverflow.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文简称 BYOL 论文标题：Bootstrap Your Own Latent A New Approach to Self-Supervised Learning 作者：Jean-Bastien Grill, Florian Strub, Florent Altché, Corentin Tallec, Pierre H. Richemond, Elena Buchatskaya, Carl">
<meta property="og:type" content="article">
<meta property="og:title" content="论文阅读：Bootstrap Your Own Latent A New Approach to Self-Supervised Learning">
<meta property="og:url" content="https://timeoverflow.github.io/2022/03/15/paper-byol/index.html">
<meta property="og:site_name" content="时间溢出的地方">
<meta property="og:description" content="本文简称 BYOL 论文标题：Bootstrap Your Own Latent A New Approach to Self-Supervised Learning 作者：Jean-Bastien Grill, Florian Strub, Florent Altché, Corentin Tallec, Pierre H. Richemond, Elena Buchatskaya, Carl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121551192.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203122317715.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121838423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121841515.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121844061.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121849215.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203122003274.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203122249021.png">
<meta property="og:image" content="c:/Users/Zhao%20Zhang/AppData/Roaming/Typora/typora-user-images/image-20220312230441849.png">
<meta property="og:image" content="https://generallyintelligent.ai/understanding_self_supervised/simclr_arch.png">
<meta property="og:image" content="https://generallyintelligent.ai/understanding_self_supervised/moco_v2_arch.png">
<meta property="og:image" content="https://generallyintelligent.ai/understanding_self_supervised/byol_arch.png">
<meta property="og:image" content="https://generallyintelligent.ai/understanding_self_supervised/surprising_stl10_10e.png">
<meta property="og:image" content="https://generallyintelligent.ai/understanding_self_supervised/contrastive_loss_arch.png">
<meta property="og:image" content="https://generallyintelligent.ai/understanding_self_supervised/cosine_similarity_10e.png">
<meta property="og:image" content="https://generallyintelligent.ai/understanding_self_supervised/accuracy_resnet_batch_norm.png">
<meta property="og:image" content="https://generallyintelligent.ai/understanding_self_supervised/accuracy_resnet_group_norm.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203142301812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203151013951.jpg">
<meta property="article:published_time" content="2022-03-15T02:07:47.000Z">
<meta property="article:modified_time" content="2022-03-15T02:38:27.855Z">
<meta property="article:author" content="TimeOverflow">
<meta property="article:tag" content="自监督学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121551192.png">

<link rel="canonical" href="https://timeoverflow.github.io/2022/03/15/paper-byol/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>论文阅读：Bootstrap Your Own Latent A New Approach to Self-Supervised Learning | 时间溢出的地方</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">时间溢出的地方</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/TimeOverflow" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://timeoverflow.github.io/2022/03/15/paper-byol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="TimeOverflow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="时间溢出的地方">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          论文阅读：Bootstrap Your Own Latent A New Approach to Self-Supervised Learning
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-15 10:07:47 / 修改时间：10:38:27" itemprop="dateCreated datePublished" datetime="2022-03-15T10:07:47+08:00">2022-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a>
                </span>
            </span>

          
            <span id="/2022/03/15/paper-byol/" class="post-meta-item leancloud_visitors" data-flag-title="论文阅读：Bootstrap Your Own Latent A New Approach to Self-Supervised Learning" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/15/paper-byol/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/15/paper-byol/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文简称 BYOL</p>
<p>论文标题：Bootstrap Your Own Latent A New Approach to Self-Supervised Learning</p>
<p>作者：Jean-Bastien Grill, Florian Strub, Florent Altché, Corentin Tallec, Pierre H. Richemond, Elena Buchatskaya, Carl Doersch, Bernardo Avila Pires, Zhaohan Daniel Guo, Mohammad Gheshlaghi Azar, Bilal Piot, Koray Kavukcuoglu, Rémi Munos, Michal Valko，来自 DeepMind 和 Imperial College  </p>
<p>发表于  NIPS 2020</p>
<p>地址：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2006.07733">arXiv</a>, <a target="_blank" rel="noopener" href="https://proceedings.neurips.cc//paper/2020/hash/f3ada80d5c4ee70142b17b8192b2958e-Abstract.html">NIPS</a></p>
<p>参考代码：<a target="_blank" rel="noopener" href="https://github.com/deepmind/deepmind-research/tree/master/byol">官方代码-TensorFlow</a>, <a target="_blank" rel="noopener" href="https://github.com/lucidrains/byol-pytorch">第三方代码1-PyTorch</a>, <a target="_blank" rel="noopener" href="https://github.com/sthalles/PyTorch-BYOL">第三方代码2-PyTorch</a></p>
<span id="more"></span>
<h2 id="核心思想"><span class="post-title-index">1. </span><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>如摘要所说，BYOL 用了两个网络，online network 和 target network，一张图片通过 augmentation 产生两个 view，online network 提取一个 view 的特征来预测 target network 提取的另一个 view 的特征；在更新的时候，online network 通过梯度反向传播更新，target network 通过动量法用 online network 来更新。</p>
<p>本文的独特点在于不需要使用 negative pairs，但并不会带来 collapsed solution。文中表示因为不需要负样本，所以 BOLY 对data augmentation 的要求也没那么高（对比 SimCLR 和 Moco v2），在这一点上更加 roubust，同样，对 batch size 的大小要求也没那么高（对比 SimCLR）。</p>
<p>文章 3. Method 开头两段话讲了本文想法的动机。作者说，如果 online network 和 target network 都根据梯度下降更新（如 SimCLR 那样），这种没有 negative pairs 的方法很容易就坍缩了，即两个网络不管输入是什么，都输出全 0 的向量，这样 loss 直接为 0 了。一个很直接的解决思路是让 target network 的权重随机初始化后直接 fix，只更新 online network，让其来预测 target network 的表示。作者做了这样的实验，发现这样效果并不好（但好于直接使用随机初始化权重的网络）。那既然不能直接固定住 target network，就让它也更新叭，又不能直接用梯度下降更新，那就打 online network 的主意了。因为 online network 一直是在更新的，我们有理由认为这样会使得 online network 对数据的特征表示越来越好，用 online network 的权重来缓慢更新 target network 的权重，这样可以提升 target network 的 representation 的 quality。这样一来，等于说我们用当前 online network 的输出来预测之前 online network 的输出，就有种自举的感觉了，也就是题目 bootstrap 的来源。</p>
<h2 id="总体框架"><span class="post-title-index">2. </span><a href="#总体框架" class="headerlink" title="总体框架"></a>总体框架</h2><h3 id="方法介绍"><span class="post-title-index">2.1. </span><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><p>本文的 flowchart 是很简洁的，通过下图可以一目了然：</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121551192.png" alt style="zoom:80%;"></p>
<p>图中的 <code>sg</code> 是 stop gradient 的意思，也就是 $\xi$ 这一条网络不通过梯度下降更新，而是用动量法从 $\theta$ 那里更新的：</p>
<script type="math/tex; mode=display">
\xi \leftarrow \tau \xi+(1-\tau) \theta</script><p>$\theta$ 那一条通路里有个 projection head，这在 $\xi$ 那一条通路里是没有的，使得整个结构是非对称的。将 $q_{\theta}(z_{\theta})$ 和 $z^\prime_{\xi}$ 分别归一化后计算 mean square error，即让 $\theta$ 这一路的表示来预测 $\xi$ 这一路的表示。文中记 $\overline{q_{\theta}}\left(z_{\theta}\right) \triangleq q_{\theta}\left(z_{\theta}\right) /\left|q_{\theta}\left(z_{\theta}\right)\right|_{2}$, $\bar{z}_{\xi}^{\prime} \triangleq z_{\xi}^{\prime} /\left|z_{\xi}^{\prime}\right|_{2}$，损失函数是这样写的：</p>
<script type="math/tex; mode=display">
\mathcal{L}_{\theta, \xi} \triangleq\left\|\overline{q_{\theta}}\left(z_{\theta}\right)-\bar{z}_{\xi}^{\prime}\right\|_{2}^{2}=2-2 \cdot \frac{\left\langle q_{\theta}\left(z_{\theta}\right), z_{\xi}^{\prime}\right\rangle}{\left\|q_{\theta}\left(z_{\theta}\right)\right\|_{2} \cdot\left\|z_{\xi}^{\prime}\right\|_{2}}</script><p>这个等式成立的原因是 $\Vert a \Vert_2^2 = <a, a>$，其中 $<a, a> = a \cdot a$，也就是向量的点乘。为了简化，记 $a = q_{\theta}\left(z_{\theta}\right)$, $\overline{a} =  \overline{q_{\theta}}\left(z_{\theta}\right)$, $b = z_{\xi}^{\prime}$, $\overline{b} = \bar{z}_{\xi}^{\prime}$，则：</a,></a,></p>
<script type="math/tex; mode=display">
\begin{aligned}
\Vert \overline{a} - \overline{b} \Vert_2^2 &= <\overline{a} - \overline{b}, \overline{a} - \overline{b}> \\
&= <\frac{a}{\Vert a \Vert_2} - \frac{b}{\Vert b \Vert_2}, \frac{a}{\Vert a \Vert_2} - \frac{b}{\Vert b \Vert_2}> \\
&= \frac{<a,a>}{\Vert a \Vert_2^2} + \frac{<b,b>}{\Vert b \Vert_2^2} - 2\cdot\frac{<a, b>}{\Vert a \Vert_2 \Vert b \Vert_2} \\
&= 2 - 2\cdot\frac{<a, b>}{\Vert a \Vert_2 \cdot \Vert b \Vert_2}
\end{aligned}</script><p>上面这个 $\mathcal{L}_{\theta,\xi}$ 是将 $v$ 通过 online network，$v^\prime$ 通过 target network 生成特征在计算损失；接下来还要做一个将 $v^\prime$ 通过 online network，$v$ 通过 target network 生成特征在计算损失，得到 $\widetilde{\mathcal{L}}_{\theta, \xi}$。也就是说，既要让 $v$ 来预测 $v^\prime$ 的特征，又要让 $v^\prime$ 来预测 $v$ 的特征。最后的损失函数是二者相加，得 $\mathcal{L}_{\theta, \xi}^{\mathrm{BYOL}}=\mathcal{L}_{\theta, \xi}+\widetilde{\mathcal{L}}_{\theta, \xi}$。online network 的参数由梯度下降更新：</p>
<script type="math/tex; mode=display">
\theta \leftarrow \operatorname{optimizer}\left(\theta, \nabla_{\theta} \mathcal{L}_{\theta, \xi}^{\mathrm{BYOL}}, \eta\right)</script><h3 id="实现细节"><span class="post-title-index">2.2. </span><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>数据增强方法用的跟 SimCLR 类似，但感觉更复杂，直接引用原文：</p>
<blockquote>
<p>First, a random patch of the image is selected and resized to 224 × 224 with a random horizontal flip, followed by a color distortion, consisting of a random sequence of brightness, contrast, saturation, hue adjustments, and an optional grayscale conversion. Finally Gaussian blur and solarization are applied to the patches.  </p>
</blockquote>
<p>网络结构方面，最基础的版本是 ResNet-50，也用了更深、更宽的 ResNet 做实验。本文的 projection head 和 prediction head 使用的都是一样的 MLP 结构：Linear (2048 to 4096) — BN — ReLU — Linear (4096 to 256)。作者特意提到，Contrary to SimCLR, the output of this MLP is not batch normalized 。但我在 SimCLR 文中没看到提及 projection head 使用了 BN，在这份<a target="_blank" rel="noopener" href="https://github.com/sthalles/SimCLR/blob/master/models/resnet_simclr.py">实现代码</a>中也没看到用 BN（最新：在<a target="_blank" rel="noopener" href="https://github.com/google-research/simclr/blob/master/tf2/model.py">官方代码</a>中看到使用 BN 了）。关于 BOYL 中使用 BN 引起了很多讨论，后文会再做一个分析。</p>
<p>优化器使用的是 LARS，学习率策略使用的是 cosine decay without restarts，训练超过 1000 epochs，其中 10 个 epoch 来 warm up。学习率为 $0.2 \times \operatorname{BatchSize}/256$，weight decay  设为 $1.5 \times 10^{-6}$。对于 target network 权重动量更新的 $\tau$，设置从初始的 $\tau_{\operatorname{base}}=0.996$ 逐渐增大到 1，具体来说，其策略为 $\tau \triangleq 1-\left(1-\tau_{\text {base }}\right) \cdot(\cos (\pi k / K)+1) / 2$，其中 $k$ 是 training step，$K$ 是一个 epoch 的最大步数。训练使用的 batch size 是 4096。</p>
<p>下面是附录里给出的算法流程：</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203122317715.png" alt="image-20220312231729520" style="zoom:80%;"></p>
<h2 id="实验结果"><span class="post-title-index">3. </span><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="Linear-evaluation-on-ImageNet"><span class="post-title-index">3.1. </span><a href="#Linear-evaluation-on-ImageNet" class="headerlink" title="Linear evaluation on ImageNet"></a>Linear evaluation on ImageNet</h3><p>使用 linear probe 测试学到的表示在 ImageNet 测试集上的分类准确率：</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121838423.png" alt="image-20220312183844265" style="zoom:80%;"></p>
<p>另外给出文中 Figure 1 的直观比较图：</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121841515.png" alt="image-20220312184117875" style="zoom:80%;"></p>
<h3 id="Semi-supervised-training-on-ImageNet"><span class="post-title-index">3.2. </span><a href="#Semi-supervised-training-on-ImageNet" class="headerlink" title="Semi-supervised training on ImageNet"></a>Semi-supervised training on ImageNet</h3><p>与 SimCLR 中的设置一样，这里也使用 ImageNet 中 1%（每类 ~12.8 张图片） 和 10%（（每类 ~128 张图片））的数据对网络进行 fine tune，下面是结果对比：</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121844061.png" alt="image-20220312184435826"></p>
<h3 id="Transfer-to-other-classification-tasks"><span class="post-title-index">3.3. </span><a href="#Transfer-to-other-classification-tasks" class="headerlink" title="Transfer to other classification tasks"></a>Transfer to other classification tasks</h3><p>迁移到其他数据集上分类。使用的模型为 ResNet-50（SimCLR 使用的是 ResNet-50 x4）。下面是结果对比：</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203121849215.png" alt="image-20220312184945126"></p>
<h3 id="Transfer-to-other-vision-tasks"><span class="post-title-index">3.4. </span><a href="#Transfer-to-other-vision-tasks" class="headerlink" title="Transfer to other vision tasks"></a>Transfer to other vision tasks</h3><p>在 VOC 2012 上做了语义分割，以 mIoU  作为指标；在 VOC trainval2007 上训练目标检测网络 Faster RCNN，在 VOC test2007 上测试，以 AP50 作为指标，结果如下，可以看出，效果好于监督学习预训练的网络。</p>
<p>在 NYU v2 数据集上做深度估计实验，结果如下。</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203122003274.png" alt="image-20220312200335035"></p>
<h2 id="消融实验"><span class="post-title-index">4. </span><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h2><h3 id="Batch-size-和-image-augmentation"><span class="post-title-index">4.1. </span><a href="#Batch-size-和-image-augmentation" class="headerlink" title="Batch size 和 image augmentation"></a>Batch size 和 image augmentation</h3><p>作者提出，因为不需要负样本，所以 BYOL 相比于 SimCLR，不需要很大的 batch size 才能获得比较好的 performance，文中的实验表明，随着 batch size 的减小，BYOL 掉点没 SimCLR 那么厉害。但从图中我们也可以看出，batch size 从 256 降低到 128 时，BYOL 突然掉了很多，这一点在本文的 Review 中也被提到过。</p>
<p>在 augmentation 方面，SimCLR 非常依赖于 color distortion，在 SimCLR 文中也提到过，一张图片的不同 crop 的 color histogram 都比较相近，如果不做 color distortion，模型很容易学到 trivial solution。BYOL 宣称它们的方法是预测 target representation，网络会尽力包含所有需要的信息而不仅仅是学到 color 信息，但这个解释我觉得是比较牵强的。</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203122249021.png" alt="image-20220312224911247" style="zoom:80%;"></p>
<h3 id="tau-的大小"><span class="post-title-index">4.2. </span><a href="#tau-的大小" class="headerlink" title="$\tau$ 的大小"></a>$\tau$ 的大小</h3><p>target network 的权重更新为：</p>
<script type="math/tex; mode=display">
\xi \leftarrow \tau \xi+(1-\tau) \theta</script><p>$\tau = 0$ 时，target network 完全跟着 online network，这时候就容易学到 trivial solution，造成模型坍缩；$\tau = 1$ 时，target network 从来不更新，这样也会带来下降。具体的 $\tau$ 值对效果的影响如下（表中数据是 ImageNet 上的 top-1 accuracy）：</p>
<p><img src="C:/Users/Zhao Zhang/AppData/Roaming/Typora/typora-user-images/image-20220312230441849.png" alt="image-20220312230441849"></p>
<p>这个表里给的是 $\tau_{\text{base}}$，前面提到，$\tau$ 的更新是根据 $\tau_{\text{base}}$ 来的：$\tau \triangleq 1-\left(1-\tau_{\text {base }}\right) \cdot(\cos (\pi k / K)+1) / 2$。所以当 $\tau_{\text{base}}=1$ 时，$\tau = 1$，即 target network 从不更新。当 $\tau_{\text{base}}=0$ 时，根据公式 $\tau$ 不一直等于 0，所以这里加了个注释说 $\tau$ 在训练中就恒定设为 0 了。</p>
<p>另外还有一些其他的 ablations，我这里就不写了。</p>
<h2 id="后续讨论"><span class="post-title-index">5. </span><a href="#后续讨论" class="headerlink" title="后续讨论"></a>后续讨论</h2><h3 id="一个博客的观点"><span class="post-title-index">5.1. </span><a href="#一个博客的观点" class="headerlink" title="一个博客的观点"></a>一个博客的观点</h3><p>这篇 <a target="_blank" rel="noopener" href="https://generallyintelligent.ai/blog/2020-08-24-understanding-self-supervised-contrastive-learning/">来自 untitled-ai 的博客</a> 在复现 BYOL 代码的时候得出两个观点：</p>
<ol>
<li>BYOL 中 BN 层是很重要的，如果没有 BN，那么结果跟一个随机初始化的网络没什么差别</li>
<li>根据上面一个结论，认为 BYOL 虽然宣称不需要负样本，但 BN 的存在事实上隐式地（implicitly）提供了负样本</li>
</ol>
<p>博文首先比较了 SimCLR, MoCo v2 和 BYOL 中 projection head (BYOL 中还包括 prediction head) 所用的 MLP 是否包含了 BN 层，给出以下几个方法框架图：</p>
<p><img src="https://generallyintelligent.ai/understanding_self_supervised/simclr_arch.png" alt="SimCLR architecture" style="zoom: 67%;"></p>
<p><img src="https://generallyintelligent.ai/understanding_self_supervised/moco_v2_arch.png" alt="MoCo v2 architecture" style="zoom:67%;"></p>
<p><img src="https://generallyintelligent.ai/understanding_self_supervised/byol_arch.png" alt="BYOL architecture" style="zoom: 52%;"></p>
<p>可以看出，SimCLR 的 MLP 中两个 FC 层后面都用了 BN，MoCO v2 则是在 MLP 中一个 BN 都没用，而 BYOL 中的 MLP 则是第一个 FC 后面用了 BN，而第二个 FC 后面没用 BN。</p>
<p>博文的作者基于 MoCo 的代码修改来复现 BYOL，因此 MLP 中是不含 BN，结果却发现 BYOL 中如果 head 不用 BN，初始时候直接就模型坍缩了，与随机初始化网络的结果没什么区别，见下图。需要说明的是，博文作者复现使用的是 ResNet-18 作为 encoder，在 STL-10 数据库上训练和测试，使用 SGD 优化器，batch size 设置为 256。</p>
<p><img src="https://generallyintelligent.ai/understanding_self_supervised/surprising_stl10_10e.png" alt="MoCo v2 architecture"></p>
<font color="gray">Linear evaluation accuracy on a validation set during early training of a ResNet-18 on STL10. When BYOL was trained without batch normalization in the MLP, the performance remained no better than a random baseline.</font>

<p>为了探究为什么不用 BN 会造成这样的结果，作者修改了损失函数，显式地使用负样本对和对比损失，形成下面这个比较像 MoCo v2 的结构，当然与 MoCo v2 不同的是，online network 多了一层 prediction head。</p>
<p><img src="https://generallyintelligent.ai/understanding_self_supervised/contrastive_loss_arch.png" alt="Contrastive loss architecture" style="zoom:52%;"></p>
<p>这下发现，在初始 10 个 epoch 并没有发生坍缩，准确率相比于随机初始化网络有了较大提升。接着作者又做了其他几个实验，包括使用 Layer Norm，以及是否在 projection head 和 prediction head 中使用 BN，结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th>Projection MLP Norm</th>
<th>Prediction MLP Norm</th>
<th>Loss Function</th>
<th>Contrastive</th>
<th>Performance</th>
</tr>
</thead>
<tbody>
<tr>
<td>Contrastive Loss</td>
<td>None</td>
<td>None</td>
<td>Cross Entropy</td>
<td>Explicit</td>
<td>44.1</td>
</tr>
<tr>
<td>BYOL</td>
<td>Batch Norm</td>
<td>Batch Norm</td>
<td>L2</td>
<td>Implicit</td>
<td>57.7</td>
</tr>
<tr>
<td>Projection BN Only</td>
<td>Batch Norm</td>
<td>None</td>
<td>L2</td>
<td>Implicit</td>
<td>55.3</td>
</tr>
<tr>
<td>Prediction BN Only</td>
<td>None</td>
<td>Batch Norm</td>
<td>L2</td>
<td>Implicit</td>
<td>48</td>
</tr>
<tr>
<td>No Normalization</td>
<td>None</td>
<td>None</td>
<td>L2</td>
<td>None</td>
<td>28.3</td>
</tr>
<tr>
<td>Layer Norm</td>
<td>Layer Norm</td>
<td>Layer Norm</td>
<td>L2</td>
<td>None</td>
<td>29.4</td>
</tr>
<tr>
<td>Random</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>None</td>
<td>28.8</td>
</tr>
</tbody>
</table>
</div>
<p>根据表格数据得出以下几条发现：</p>
<ol>
<li>因为没使用对比损失，所以 BYOL 很依赖 BN</li>
<li>BN 使得同一批次不同样本之间的信息得到交互，这是一个关键因素，LN 因为只与自己本身做 norm，因而效果也不好</li>
<li>projection head 和 prediction head 二者中有一个用 BN 就能带来效果上的提升，但 projection head 中的 BN 提升效果更明显</li>
</ol>
<p>博文中说，为什么 BN 能阻止模型坍缩呢，因为坍缩的表现就是所有输出都是 $[1, 0, \cdots, 0]$ 这样的向量，而 BN 的 normalization 正是避免这样的情况发生的。另外，博文认为，BN 隐式地提供了负样本，这个负样本就是一个 mini-batch 里的 average image，所有的样本都会跟这个 average image 做对比。</p>
<p>博文还做了进一步验证，在每个 mini-batch 中，把正样本对和负样本对（虽然 BYOL 中是不计算负样本对的，但每个 mini-batch 中还是可以跟 SimCLR 一样选择正负样本对）的 projection head 的输出特征（也就是上面 BYOL 图中的 $z$ 和 $z^\prime$）计算 cosine similarity，如果模型没有坍缩，那么正样本对的 cosine similarity 应该大于负样本对，下面的结果也证实了这一点：</p>
<p><img src="https://generallyintelligent.ai/understanding_self_supervised/cosine_similarity_10e.png" alt="Contrastive loss architecture"></p>
<font color="gray">The average cosine similarity between the projections z and z'. The lower (blue) bar is the similarity between projections of the same image x, while the upper (red) bar is the similarity between projections of different images in the same mini-batch. The high similarity of all representations for the no MLP normalization experiment and the layer normalization experiment indicates mode collapse.</font>

<p>注意，以上的结果都是只训练了 10 个 epoch 的模型结果，作者发现继续训练的话，即使 MLP 中不用 BN，模型也能从坍缩中走出来，这被作者认为是 ResNet 中的 BN 的作用。</p>
<p>如果把 ResNet 中的 BN 也移除了呢，那模型就完全不能 work 了。但等等，还不是这样，到此为止，上面的实验都是用了 SGD 优化器中，博文作者在咨询了 BYOL 论文作者后，他们说你要是用 LARS 优化器就不会因为没有 BN （指整个网络一个 BN 都没有）而坍缩了，作者试了一下发现确实是这样，但效果确实比使用 BN 变差了，并且这样很依赖精细调参。所以总的来说，还是 BN 起到了很大的作用。</p>
<p>博文的附录中还有几个 longer training 的实验，一是比较了去掉 MLP 中 BN 的情况，如下图。可以发现，只要 ResNet 中还有 BN，模型就不会坍缩，并且这种情况下使用 LARS 优化器要比 SGD 优化器更好，但还是比不过 MLP 中加了 BN 的情况。</p>
<p><img src="https://generallyintelligent.ai/understanding_self_supervised/accuracy_resnet_batch_norm.png" alt="Accuracy for ResNet with batch norm"></p>
<p>另外一个实验是把 ResNet 中的 BN 全部换成 Group Normalization，这样如果 MLP 中不加 BN，那整个网络就都没有 BN 了，实验对比如下。实验结果表明，如果整个网络里一个 BN 都没有，用 SGD 优化器就直接坍缩了；如果用 LARS 优化器，需要调参，学习率在 0.2 的时候没问题，学习率变成 0.1 的时候就又坍缩了，这说明网络中没有 BN 的话，即使用 LARS 优化器，也得精细调参才行。而如果 MLP 中有 BN，在 ResNet 也没有 BN 的情况下，模型仍然能训练得起来。</p>
<p><img src="https://generallyintelligent.ai/understanding_self_supervised/accuracy_resnet_group_norm.png" alt="Accuracy for ResNet with group norm"></p>
<p>附录中还提出了在不用 BN 时防止模型坍缩的方法，包括使用 Weight Decay 和 Weight Standardization，这里就略过了。</p>
<h3 id="论文作者对博文的回应"><span class="post-title-index">5.2. </span><a href="#论文作者对博文的回应" class="headerlink" title="论文作者对博文的回应"></a>论文作者对博文的回应</h3><p>在博客出来之后，BYOL 的作者专门写了篇文章回应，标题是 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2010.10241">BYOL works even without batch statistics</a>，文章标题还特意把 <em>even</em> 这个词给斜体了。文章从两个方面反驳博文中对 BN 作用的讨论。</p>
<p>首先给出一个表格，展示了大量的消融实验（实验参数设置与 BYOL 原文中相同），如下所示。如果能保持 Encoder 中有 BN，那么模型效果其实不会受到太大影响；如果移除 Encoder 中的 BN，但保留 Projector 或 Predictor 中的 BN，那么模型效果会有所下降；如果把所有模块的 BN 都移除了或者用 LN 代替，那么 BYOL 就坍缩。作为对比，SimCLR 中的 BN 移除造成的影响没那么大，但把 BN 都移除时，SimCLR 也训练不起来。</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203142301812.png" alt="image-20220314230156618"></p>
<h4 id="随机初始化的模型-BYOL-训不好，BN-弥补了这个问题"><span class="post-title-index">5.2.1. </span><a href="#随机初始化的模型-BYOL-训不好，BN-弥补了这个问题" class="headerlink" title="随机初始化的模型 BYOL 训不好，BN 弥补了这个问题"></a>随机初始化的模型 BYOL 训不好，BN 弥补了这个问题</h4><p>根据以上实验，作者认为 BN 发挥作用的主要部分在 Encoder 中，进而猜想这表明 BN 的作用并不是隐式地带来负样本，而是对模型初始化起到了很好的补偿作用。也就是说，作者认为，随机初始化的模型是一个 improper initialization，直接训练的话就会把模型训歪，但是如果用了 BN，就可以弥补随机初始化带来的问题。</p>
<p>为了证明这个猜想，作者说那我就去掉 BN，但我又要保留 BN 补偿随机初始化的作用，用原文中的话说，叫 to mimic the effect of BN on initial scalings and training dynamics, without using or backpropagating through batch statistics.  文中在训练前先前向计算一下网络，通过 mini-batch 的数据计算来初始化一下 BN 中的可训练参数 $\gamma$ 和 $\beta$，在训练网络的时候，保留这两个参数（这样就保留了 BN 的 scaling 作用），但不用计算 mini-batch 的统计信息，作者认为这样就等于是 remove BN 了（具体操作细节还是看文章中的描述）。这样的操作使得模型在没有 BN 的情况下达到了 65.7% top-1 accuracy in the linear evaluation。PS: 我是不认可这个说法的，这个实验虽然去掉了 BN，但在训练前的前向过程中计算了 mini-batch 的统计信息用于初始化 $\gamma$ 和 $\beta$，这之间引入了什么就说不清了。</p>
<h4 id="使用-Group-Normalization-和-Weight-Standardization-可以提升效果"><span class="post-title-index">5.2.2. </span><a href="#使用-Group-Normalization-和-Weight-Standardization-可以提升效果" class="headerlink" title="使用 Group Normalization 和 Weight Standardization 可以提升效果"></a>使用 Group Normalization 和 Weight Standardization 可以提升效果</h4><p>上面说的去掉 BN 也可以不坍缩，但结果相比于使用 BN 的 74.3% 还是有些差距的。作者又做了新的实验，这次用了 GN 代替所有的 BN （这样就真的不会跟 mini-batch 中的其他数据产生交互了），然后又对每一层用来 WS，再经过精细调参（which 我觉得很没意思），在训练了 1000 个 epoch 之后，终于把结果提升到 73.9%。</p>
<blockquote>
<p>什么是 Weight Standardization 呢，我直接引用原文的话了，因为我实在不想写了。</p>
<p>WS  normalizes the weights corresponding to each activation using weight statistics. Each row of the weight matrix $W$ is normalized to get a new weight matrix $\widehat{W}$ which is directly used in place of $W$ during training. Only the normalized weights $\widehat{W}$ are used to compute convolution outputs but the loss is differentiated with respect to non-normalized weights $W,$</p>
<script type="math/tex; mode=display">
\widehat{W}_{i,j} = \frac{W_{i,j} - \mu_i}{\sigma_i}
\quad \text{with} \quad
\mu_i = \frac{1}{\mathcal{I}}\sum_{j=1}^\mathcal{I} W_{i,j}
\quad \text{and} \quad
\sigma_i = \sqrt{\epsilon + \frac{1}{\mathcal{I}}\sum_{j=1}^\mathcal{I}({W_{i,j} - \mu_i})^2},</script><p>where $\mathcal{I}$ is the input dimension (product of input channel dimension and kernel spatial dimension); we set $\epsilon = 10^{-4}$. </p>
</blockquote>
<p>这篇回应的文章我不太赞同，虽然做了这么多实验说 BYOL 不依赖 BN，但是用了这么多复杂的技术和 trick 以及调参，已经说明 BN 的重要性了（简单地使用 BN 就能代替这么多操作哦），这么多复杂操作只能说明 BYOL 不 robust 了。这篇回应文章应该还是要维护 BYOL 文中提出的卖点：不需要使用负样本。我觉得这个卖点对实际使用没什么太大的帮助（对发文章来说还是必要的），还不如老老实实承认 BN 确实有用呢。</p>
<h2 id="写在最后"><span class="post-title-index">6. </span><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>写这个笔记的时候，正值学校因为疫情封校封楼（3 月 9 号封校，3 月 12 号封楼）。在寝室蜗居数日，并眼看着每日新增病例，心情不免比较低沉。下图是出去核酸检测路上拍的照片，只有核酸检测时才能看看春天了。惟愿疫情早日结束，大家都健健康康。</p>
<p><img src="https://raw.githubusercontent.com/TimeOverflow/picgo-images/master/202203151013951.jpg" alt="IMG_20220313_130240" style="zoom: 15%;"></p>
<center><font color="gray">客舍青青柳色新</font></center>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" rel="tag"># 自监督学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/08/migrate-blog/" rel="prev" title="如何迁移这个博客">
      <i class="fa fa-chevron-left"></i> 如何迁移这个博客
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-text">1. 核心思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="nav-text">2. 总体框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">2.1. 方法介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-text">2.2. 实现细节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="nav-text">3. 实验结果</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linear-evaluation-on-ImageNet"><span class="nav-text">3.1. Linear evaluation on ImageNet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semi-supervised-training-on-ImageNet"><span class="nav-text">3.2. Semi-supervised training on ImageNet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transfer-to-other-classification-tasks"><span class="nav-text">3.3. Transfer to other classification tasks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transfer-to-other-vision-tasks"><span class="nav-text">3.4. Transfer to other vision tasks</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%9E%8D%E5%AE%9E%E9%AA%8C"><span class="nav-text">4. 消融实验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Batch-size-%E5%92%8C-image-augmentation"><span class="nav-text">4.1. Batch size 和 image augmentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tau-%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-text">4.2. $\tau$ 的大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E7%BB%AD%E8%AE%A8%E8%AE%BA"><span class="nav-text">5. 后续讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%A7%82%E7%82%B9"><span class="nav-text">5.1. 一个博客的观点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E5%AF%B9%E5%8D%9A%E6%96%87%E7%9A%84%E5%9B%9E%E5%BA%94"><span class="nav-text">5.2. 论文作者对博文的回应</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%A8%A1%E5%9E%8B-BYOL-%E8%AE%AD%E4%B8%8D%E5%A5%BD%EF%BC%8CBN-%E5%BC%A5%E8%A1%A5%E4%BA%86%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-text">5.2.1. 随机初始化的模型 BYOL 训不好，BN 弥补了这个问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Group-Normalization-%E5%92%8C-Weight-Standardization-%E5%8F%AF%E4%BB%A5%E6%8F%90%E5%8D%87%E6%95%88%E6%9E%9C"><span class="nav-text">5.2.2. 使用 Group Normalization 和 Weight Standardization 可以提升效果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="nav-text">6. 写在最后</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TimeOverflow"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">TimeOverflow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TimeOverflow" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TimeOverflow" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhangz1220@outlook.com" title="E-Mail → mailto:zhangz1220@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TimeOverflow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">115k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'N3GrQmFE8RVjH8Sk6s4B7xnY-9Nh9j0Va',
      appKey     : '4KwTSki3hoVvxnEwsxogPOKb',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
